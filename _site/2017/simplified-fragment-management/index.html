<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Simplified Fragment Management</title>
  <meta name="description" content="Android Developer. Gadget dependent. Music addicted.">
  <meta name="author" content="Dusko Bajic">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Simplified Fragment Management">
  
  
  <meta name="twitter:description" content="EasyFragmentManager is basically a wrapper around FragmentManager and exposes 'add', 'replace', 'popUp', 'onBackPressed' and 'getCurrentFragment' methods. EasyFragmentManager assumes that...">
  
  <meta name="twitter:site" content="@bajicdusko">

  <meta property="og:type" content="article">
  <meta property="og:title" content="Dusko Bajic">
  <meta property="og:description" content="Android Developer. Gadget dependent. Music addicted.">

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://bajicdusko.com//2017/simplified-fragment-management/">
  <link rel="alternate" type="application/rss+xml" title="Dusko Bajic" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of Dusko Bajic">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Dusko Bajic</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Android Developer. Gadget dependent. Music addicted.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="link to Dusko Bajic blog" class="blog-button">Blog</a></li>
              <li class="navigation__item"><a href="/bio" title="link to Dusko Bajic contact" class="contact-button">Bio/Contact</a></li>
            </ul>
          </nav>
        </div>
        <div class="navigation-wrapper">
          <nav class="cover-navigation navigation--social">
            <ul class="navigation">

            
              <!-- Twitter -->
              <li class="navigation__item">
                <a href="http://twitter.com/bajicdusko" title="@bajicdusko on Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>
            

            

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/bajicdusko" title="bajicdusko on LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/bajicdusko" title="bajicdusko on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            
              <!-- Email -->
              <li class="navigation__item">
                <a href="mailto:bajicdusko@gmail.com" title="Email bajicdusko@gmail.com" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>
            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="8 Jun 2017" class="post-meta__date date">8 Jun 2017</time> &#8226; <span class="post-meta__tags">on <a href="/tags/#android">android</a> <a href="/tags/#fragment">fragment</a> <a href="/tags/#fragmentmanager">fragmentmanager</a> </span>
    </div>
    <h1 class="post-title">Simplified Fragment Management</h1>
  </header>

  <section class="post">
    <p>Handling fragments(lifecycle) in android app was complicated from the beginning.
Nowadays, a lot of internal bugs is fixed, but still there is a general negativity
towards fragment usage.</p>

<p>Many developers are avoiding fragments and returning to old fashion apps with the large
number of the activities. Just because it’s “complicated”, it
does not mean that we have to stop using it. Fragments are (at the moment) part of
our apps and we have to deal with it the best we can.</p>

<p>These issues might feel a little bit basic, however, by working on many android apps, I’ve noticed few constant problem-patterns (listed-below) when it comes to fragments. If you’d just like to jump to implementation, <a href="#solution">click here</a>.</p>

<ol>
  <li>
    <p><strong>Getting instance of Fragment</strong> (for whatever reason) from the existing stack of transactions, regardless of the position in the stack.</p>

    <p>One way of getting the last added fragment might be this one:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">//fetching all fragments</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Fragment</span><span class="o">&gt;</span> <span class="n">fragments</span> <span class="o">=</span> <span class="n">fragmentManager</span><span class="o">.</span><span class="na">getFragments</span><span class="o">();</span>

<span class="c1">//getting last added fragment</span>
<span class="n">Fragment</span> <span class="n">currentFragment</span> <span class="o">=</span> <span class="n">fragments</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">fragments</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</code></pre>
    </div>

    <p>Although this approach makes sense, it is possible that some fragments are removed in the meantime and this list will contain <code class="highlighter-rouge">null</code> (instead of trimmed size).</p>

    <p>If, for example, we have <code class="highlighter-rouge">three</code> fragments on stack and we just tapped back button, we might get <code class="highlighter-rouge">fragment.size() == 3</code> but
actual number of fragments is <code class="highlighter-rouge">two</code> and third position <code class="highlighter-rouge">fragments.get(fragments.size() - 1)</code> will return <code class="highlighter-rouge">null</code>.</p>

    <p>And I cannot point the obvious more than it is, but <strong>this is the stack</strong> and still it can happen with any other index in the list. Since we have a <code class="highlighter-rouge">List&lt;&gt;</code> interface exposed, then we can call <code class="highlighter-rouge">fragments.get(0)</code> and wow, it returns <code class="highlighter-rouge">null</code>, <code class="highlighter-rouge">fragments.size()</code> value will be incorrect and no matter what index we use, we won’t get correct fragment instance.</p>

    <p>Then we might say, ok we can use this approach instead:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">//fetching all fragments</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Fragment</span><span class="o">&gt;</span> <span class="n">fragments</span> <span class="o">=</span> <span class="n">fragmentManager</span><span class="o">.</span><span class="na">getFragments</span><span class="o">();</span>

<span class="c1">//getting the actual number of fragments from the fragmentManager</span>
<span class="kt">int</span> <span class="n">fragmentsCount</span> <span class="o">=</span> <span class="n">fragmentManager</span><span class="o">.</span><span class="na">getBackStackEntryCount</span><span class="o">();</span>

<span class="c1">//getting last added fragment</span>
<span class="n">Fragment</span> <span class="n">currentFragment</span> <span class="o">=</span> <span class="n">fragments</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">fragmentsCount</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
</code></pre>
    </div>

    <p>And great, now we have the exact number of fragments on the stack, however, <code class="highlighter-rouge">fragments</code> list
still can contain <code class="highlighter-rouge">null</code> values on any position and we’ll end up with wrong fragment or with <code class="highlighter-rouge">java.lang.IndexOutOfBoundsException</code> in the worst case. Additional work is needed anyway and it seams its a lot
of work just to get instance of fragment we have created in the first place.</p>
  </li>
  <li>
    <p><strong>Handling onBackPressed navigation and application title update</strong></p>

    <p>Typical android application shows <code class="highlighter-rouge">Toolbar</code> on top of the screen. If the <code class="highlighter-rouge">Toolbar</code> is part of the <code class="highlighter-rouge">Activity</code> layout
we need to update its <code class="highlighter-rouge">title</code> according to currently active fragment.</p>

    <p>For example:</p>

    <p><code class="highlighter-rouge">HomeActivity.java</code></p>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="nd">@Inject</span> <span class="n">FragmentManager</span> <span class="n">supportFragmentManager</span><span class="o">;</span>
<span class="nd">@BindView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">toolbar</span><span class="o">)</span> <span class="n">Toolbar</span> <span class="n">toolbar</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">){</span>
  <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
  <span class="o">...</span>
  <span class="n">setSupportActionBar</span><span class="o">(</span><span class="n">toolbar</span><span class="o">);</span>
  <span class="n">supportFragmentManager</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">()</span>
             <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">activity_home_fragment_container</span><span class="o">,</span> <span class="n">HomeFragment</span><span class="o">.</span><span class="na">newInstance</span><span class="o">())</span>
             <span class="o">.</span><span class="na">addToBackStack</span><span class="o">(</span><span class="kc">null</span><span class="o">)</span>
             <span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTitle</span><span class="p">(</span><span class="nd">@StringRes</span> <span class="kt">int</span> <span class="n">titleId</span><span class="o">){</span>
  <span class="n">getSupportActionBar</span><span class="o">().</span><span class="na">setTitle</span><span class="o">(</span><span class="n">getString</span><span class="o">(</span><span class="n">titleId</span><span class="o">));</span>
<span class="o">}</span>
</code></pre>
    </div>

    <p><code class="highlighter-rouge">HomeFragment.java</code></p>

    <div class="highlighter-rouge"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStart</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
   <span class="kd">super</span><span class="o">.</span><span class="na">onStart</span><span class="o">();</span>
   <span class="o">((</span><span class="n">HomeActivity</span><span class="o">)</span><span class="n">getActivity</span><span class="o">()).</span><span class="na">setTitle</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">string</span><span class="o">.</span><span class="na">home</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
    </div>

    <p>And this actually works. Except you might get <code class="highlighter-rouge">NullPointerException</code> sometimes or <code class="highlighter-rouge">java.lang.IllegalStateException: Fragment LoginFragment not attached to Activity</code> and honestly, I’ve stopped looking for reasons why. If you move <code class="highlighter-rouge">getActivity().setTitle(R.string.login);</code> to some other location in the fragment, <code class="highlighter-rouge">setTitle</code> might get called too late and we’re triggering bad user experience.</p>

    <p>On the other hand, when you’re popping the fragment from the stack, you have to call <code class="highlighter-rouge">setTitle()</code> method of the <code class="highlighter-rouge">Fragment</code> which is popping up and at some point <code class="highlighter-rouge">setTitle()</code> method might not get called at all, and you end up with <code class="highlighter-rouge">title</code> in the <code class="highlighter-rouge">Toolbar</code> that does not match the content.</p>

    <p>It does not have to be the title, you might want to change navigation options for different fragments, to show back arrow instead of hamburger icon etc, and setting these options will depend of some method call inside the <code class="highlighter-rouge">Fragment</code>.</p>
  </li>
  <li>
    <p><strong>Reseting stack</strong> triggers lifecycle of each fragment along the way</p>

    <p>At some point, we have to return to the starting point of the app. So we’ll be popping the fragments from the stack
until stack gets empty or until there is only one fragment shown. Not so obvious problem that occurs is that
each popped fragment gets re-instantiated with call to all lifecycle methods, and causing execution of logic we put in
each fragment. This is definitely unwanted behavior. We just want to remove them so that we can start from the beginning.</p>
  </li>
  <li>
    <p><strong>Communication</strong> between fragments and the hosting Activity should not be implemented by casting <code class="highlighter-rouge">getActivity()</code> method and I like to think that no one implements it like that. Instead, communication between activity and the fragments should be implemented via interface which <code class="highlighter-rouge">Activity</code> implements, I know, obvious.</p>
  </li>
</ol>

<p><a name="solution">Simple solution</a> I came up with have four main components:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">EasyFragmentManager</code> which is basically a wrapper around <code class="highlighter-rouge">FragmentManager</code> and exposes the methods for <code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">replace</code>, <code class="highlighter-rouge">popUp</code>, <code class="highlighter-rouge">popUpAll</code> and <code class="highlighter-rouge">getCurrentFragment</code> operations. <code class="highlighter-rouge">EasyFragmentManager</code> assumes that each <code class="highlighter-rouge">Fragment</code> implements <code class="highlighter-rouge">IFragment</code> interface.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">IFragment</code> interface is forcing each <code class="highlighter-rouge">Fragment</code> to have its own unique <code class="highlighter-rouge">name</code> or <code class="highlighter-rouge">tag</code> under which is added to transaction, <code class="highlighter-rouge">dispose()</code> method (which is very handy when implementing <code class="highlighter-rouge">RxJava2</code>), and yes, method to <code class="highlighter-rouge">setTitle()</code> of the <code class="highlighter-rouge">Toolbar/ActionBar</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">FragmentTagStack</code> to handle stack easily and retrieve fragments. It does not contain fragment instances, but its <code class="highlighter-rouge">tags</code> as <code class="highlighter-rouge">String</code> values instead and have only basic methods for <code class="highlighter-rouge">pop</code>, <code class="highlighter-rouge">popUpAll</code>, <code class="highlighter-rouge">peek</code>, <code class="highlighter-rouge">push</code> and <code class="highlighter-rouge">getActiveTag</code> which returns tag of currently shown <code class="highlighter-rouge">Fragment</code> on the screen.</p>
  </li>
  <li>
    <p>‘FragmentChannel’ is the most basic interface for callback implementation between the <code class="highlighter-rouge">Fragment</code> and hosting environment, which can be <code class="highlighter-rouge">Activity</code> or parent <code class="highlighter-rouge">Fragment</code>.</p>
  </li>
</ul>

<p>It is really simple implementation, however, it helps a lot and here are the implementation steps:</p>

<ol>
  <li>Activity initialize <code class="highlighter-rouge">EasyFragmentManager</code> and calls its <code class="highlighter-rouge">state</code> save/restore methods as well as <code class="highlighter-rouge">onBackPressed</code> method and implements <code class="highlighter-rouge">FragmentChannel</code>.</li>
  <li><code class="highlighter-rouge">EasyFragmentManager</code> initializes <code class="highlighter-rouge">FragmentTagStack</code>, and pushes and pops the <code class="highlighter-rouge">tags</code> to stack as Fragments are added or removed.</li>
  <li>Each <code class="highlighter-rouge">Fragment</code> implements <code class="highlighter-rouge">IFragment</code> interface.</li>
  <li>Tip: Usually, having <code class="highlighter-rouge">abstract BaseFragment</code> class which implements <code class="highlighter-rouge">IFragment</code> and initializes <code class="highlighter-rouge">FragmentChannel</code> is less error prone, then implementing these methods for all Fragments individually.</li>
</ol>

<p>Example implementation can be found in this <strong><a href="https://gist.github.com/bajicdusko/683766ab74b93519be27df0ae6e0793f">Gist</a></strong>. as well as implementations of described components below.
Once you establish hierarchy as below, you won’t have to think about it much. Only component that you’ll update constantly is <code class="highlighter-rouge">FragmentChannel</code> interface since you’ll be implementing all <code class="highlighter-rouge">Fragment</code> -&gt; <code class="highlighter-rouge">Activity</code> calls through it. <code class="highlighter-rouge">showLogin()</code> function in example below is one such case.</p>

<p><code class="highlighter-rouge">EasyFragmentManager.kt</code></p>

<pre><code class="language-kotlin">class EasyFragmentManager(private val fragmentManager: FragmentManager, private val fragmentContainerId: Int) {

    private val KEY_TAGS = "key_tags"
    private var fragmentTagStack: FragmentTagStack = FragmentTagStack()

    constructor(fragmentManager: FragmentManager, fragmentContainer: FrameLayout) : this(fragmentManager, fragmentContainer.id)

    fun addFragment(fragment: IFragment) {
        fragmentTagStack.push(fragment.getFragmentName())
        fragmentManager.beginTransaction()
                .add(fragmentContainerId, fragment as Fragment)
                .addToBackStack(fragment.getFragmentName())
                .commit()
    }

    fun replaceFragment(fragment: IFragment) {
        fragmentTagStack.push(fragment.getFragmentName())
        fragmentManager.beginTransaction()
                .replace(fragmentContainerId, fragment as Fragment)
                .addToBackStack(fragment.getFragmentName())
                .commit()
    }

    /**
     * When [Activity.onBackPressed] is called it is a good practice to override it and to call this method.
     * This method won't allow removal of last fragment on the stack.
     *
     * @return TRUE if fragment is poppedUp aka method is consumed, or FALSE if there is only one Fragment
     * on the stack.
     */
    fun onBackPressed(): Boolean {
        if (fragmentManager.backStackEntryCount &gt; 1) {
            popUp()
            var currentFragment = getCurrentFragment()
            currentFragment?.setTitle()
            return true
        } else {
            return false
        }
    }

    fun popUp() {
        fragmentManager.popBackStackImmediate()
        fragmentTagStack.pop()
    }

    fun popUpAll() {
        fragmentManager.popBackStack(null, FragmentManager.POP_BACK_STACK_INCLUSIVE)
        fragmentTagStack.popUpAll()
    }

    fun getCurrentFragment(): IFragment? = fragmentManager.findFragmentByTag(fragmentTagStack.activeTag) as IFragment?

    fun dispose() = getCurrentFragment()?.dispose()

    fun onSaveInstanceState(state: Bundle?) {
        state?.putParcelable(KEY_TAGS, Parcels.wrap(fragmentTagStack))
    }

    fun onRestoreInstanceState(savedInstanceState: Bundle?) {
        if (savedInstanceState != null) {
            fragmentTagStack = Parcels.unwrap(savedInstanceState.getParcelable(KEY_TAGS))
        } else {
            fragmentTagStack = FragmentTagStack()
        }
    }
}
</code></pre>

<p><code class="highlighter-rouge">FragmentTagStack.kt</code></p>

<pre><code class="language-kotlin">@Parcel(Parcel.Serialization.BEAN)
class FragmentTagStack {

    @Transient private var showLogs: Boolean = false

    var tags: MutableList&lt;String&gt;
        private set

    var activeTag: String? = null
        private set

    constructor(){
        tags = LinkedList()
    }

    @ParcelConstructor
    constructor(tags: MutableList&lt;String&gt;, activeTag: String) {
        this.tags = tags
        this.activeTag = activeTag
    }

    /**
     * Enabling or disabling fragment stack logs. Logs are disabled by default.

     * @param showLogs
     */
    fun setShowLogs(showLogs: Boolean) {
        this.showLogs = showLogs
    }

    /**
     * Pushing new tag to stack and setting is as [FragmentTagStack.activeTag]

     * @param tag
     */
    fun push(tag: String) {
        tags.add(tag)
        activeTag = tag
        logStack()
    }

    /**
     * Popping tag from the stack and setting the tag below as new [FragmentTagStack.activeTag]
     *
     *
     * Example:
     *
     *
     * Stack [3, 2, 1, 0] (3 is last added tag). [FragmentTagStack.activeTag] have value 3
     *
     *
     * Now we're popping the last added tag
     *
     *
     * Stack [2, 1, 0] [FragmentTagStack.activeTag] have value 2

     * @return Popped up value. From the example above, returned value will be 3. In case of empty stack, null will be returned.
     */
    fun pop(): String? {
        val tag = peek()
        if (!TextUtils.isEmpty(tag)) {
            tags.removeAt(tags.size - 1)
        }

        activeTag = peek()
        logStack()
        return tag
    }

    /**
     * Peeking to the top of the stack, without data modification.

     * @return Value on top of the stack. If stack is empty, returned value will be null.
     */
    fun peek(): String? {
        if (tags.size &gt; 0) {
            return tags[tags.size - 1]
        } else {
            return null
        }
    }

    private fun logStack() {
        if (showLogs) {
            val stringBuilder = StringBuilder()
            stringBuilder.append("Active tag: $activeTag\nStack:\n")
            for (i in tags.size - 1 downTo 0) {
                stringBuilder.append("[ ${tags[i]}]\n")
            }
            Log.d(TAG, stringBuilder.toString())
        }
    }

    /**
     * Clears the stack.
     */
    fun popUpAll() {
        tags.clear()
    }

    companion object {

        @Transient private val TAG = "FragmentTagStack"
    }
}
</code></pre>

<p><code class="highlighter-rouge">IFragment.kt</code></p>

<pre><code class="language-kotlin">
interface IFragment {
    fun getFragmentName(): String

    fun setTitle(): Unit?

    fun dispose()
}
</code></pre>

<p><code class="highlighter-rouge">FragmentChannel.kt</code></p>

<pre><code class="language-kotlin">
interface FragmentChannel{
  fun setTitle(title: String): Unit?
  fun showLogin()
}
</code></pre>

<p><code class="highlighter-rouge">BaseFragment.kt</code></p>

<pre><code class="language-kotlin">
abstract class BaseFragment : Fragment(), IFragment{

  var fragmentChannel: FragmentChannel? = null

  override fun onAttach(context: Context){
    super.onAttach(context)
    if(context is FragmentChannel){
      fragmentChannel = context
    }
  }

  override fun onCreate(savedInstanceState: Bundle?){
    super.onCreate(savedInstanceState)
    if(parentFragment != null &amp;&amp; parentFragment is FragmentChannel){
      fragmentChannel = parentFragment
    }
  }
}
</code></pre>

<p><code class="highlighter-rouge">HomeFragment.kt</code></p>

<pre><code class="language-kotlin">
class HomeFragment : BaseFragment() {

  private val FRAGMENT_NAME = "Home"

  companion object{
    fun newInstance() = HomeFragment()
  }

  override fun getFragmentName(): String = FRAGMENT_NAME

  override fun setTitle() = fragmentChannel?.setTitle(R.string.home)

  fun onLoginButtonClick(){
    fragmentChannel?.showLogin()
  }

  override fun dispose(){
    TODO("Call presenter dispose method")
  }
}
</code></pre>

<p><code class="highlighter-rouge">HomeActivity.kt</code></p>

<pre><code class="language-kotlin">class HomeActivity : AppCompatActivity(), FragmentChannel{

  @BindView(R.layout.activity_home_container)
  lateinit var flContainer: FrameLayout

  val easyFragmentManager by lazy {
    EasyFragmentManager(getSupportFragmentManager(), flContainer)
  }

  override fun onCreate(savedInstanceState: Bundle?){
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_home)
    ButterKnife.bind(this)
    easyFragmentManager.add(HomeFragment.newInstance())
  }

  override fun onSaveInstanceState(outState: Bundle?){
    super.onSaveInstanceState(outState)
    easyFragmentManager.onSaveInstanceState(outState)
  }

  override fun onRestoreInstanceState(savedInstanceState: Bundle?){
    super.onRestoreInstanceState(savedInstanceState)
    easyFragmentManager.onRestoreInstanceState(savedInstanceState)
  }

  override fun setTitle(titleId: Int) {
    supportActionBar?.title = getString(titleId)
  }

  override fun showLogin(){
    easyFragmentManager.replace(LoginFragment.newInstance())
  }

  override fun onBackPressed(){
    if(!easyFragmentManager.onBackPressed){
      finish();
    }
  }
}
</code></pre>

<p>And last but not least on latest Google IO (2017), guys from Google found it necessary to remind everyone about the basics as well.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/eUG3VWnXFtg" frameborder="0" allowfullscreen=""></iframe>

  </section>
  <section id="disqus_thread"></section><!-- /#disqus_thread -->
</article>

    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://bajicdusko.com/2017/simplified-fragment-management/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2017/simplified-fragment-management'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };

      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//bajicdusko.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
       })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2017 Dusko Bajic. All rights reserved.</span>
</footer> 

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

    </div>
  </body>
</html>
